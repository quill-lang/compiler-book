<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Quill and Feather specifications</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Feather</li><li class="chapter-item expanded "><a href="fsyntax/fsyntax.html"><strong aria-hidden="true">1.</strong> Feather syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fsyntax/basic_definitions.html"><strong aria-hidden="true">1.1.</strong> Basic definitions</a></li><li class="chapter-item expanded "><a href="fsyntax/preterms.html"><strong aria-hidden="true">1.2.</strong> Preterms</a></li><li class="chapter-item expanded "><a href="fsyntax/precontexts.html"><strong aria-hidden="true">1.3.</strong> Precontexts</a></li><li class="chapter-item expanded "><a href="fsyntax/preenvironments.html"><strong aria-hidden="true">1.4.</strong> Pre-environments</a></li><li class="chapter-item expanded "><a href="fsyntax/judgments.html"><strong aria-hidden="true">1.5.</strong> Judgments</a></li><li class="chapter-item expanded "><a href="fsyntax/functional_typing_rules.html"><strong aria-hidden="true">1.6.</strong> Functional typing rules</a></li><li class="chapter-item expanded "><a href="fsyntax/environmental_typing_rules.html"><strong aria-hidden="true">1.7.</strong> Environmental typing rules</a></li><li class="chapter-item expanded "><a href="fsyntax/borrowing_typing_rules.html"><strong aria-hidden="true">1.8.</strong> Borrowing typing rules</a></li><li class="chapter-item expanded "><a href="fsyntax/definitional_equality.html"><strong aria-hidden="true">1.9.</strong> Definitional equality</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Quill and Feather specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="conventions"><a class="header" href="#conventions">Conventions</a></h2>
<p>When defining a term for the first time, it will be displayed in <em>italics</em>.</p>
<h2 id="basic-ideas"><a class="header" href="#basic-ideas">Basic ideas</a></h2>
<ul>
<li>Expressive, safe, fast, in that order.</li>
<li>Compile time &quot;reference counting&quot;, leading to a borrow-checked system.</li>
<li>Expression blocks. <code>loan</code> and <code>take</code>.</li>
<li>Algebraic types. Inductive propositions. Subtypes.</li>
<li>No universe polymorphism, but still a universe hierarchy.</li>
<li>Quantitative type system. Usages correspond to the ideal storage mechanisms at runtime (given sufficient monomorphisation capabilities).</li>
<li>Monomorphisation is optional. Types at runtime; no decidable properties (what about <code>sizeof</code>?), so fully erasable. Function objects.</li>
<li>Reference tracking is inconsistent with quotients, as this would let us forget about a resource (e.g. function extensionality between a function that uses a resource and one that doesn't).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feather-syntax"><a class="header" href="#feather-syntax">Feather syntax</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-definitions"><a class="header" href="#basic-definitions">Basic definitions</a></h1>
<p>In the following, we assume familiarity with basic set theory.</p>
<h2 id="common-sets"><a class="header" href="#common-sets">Common sets</a></h2>
<p>We define</p>
<ul>
<li>\( \mathbb B = \{ \bot, \top \} \) is the two-element <em>Boolean</em> set, where \( \top \) represents truth and \( \bot \) represents falsity.</li>
<li>\( \mathbb N = \{ 0, 1, 2, \dots \} \) is the set of <em>natural numbers</em>, including zero.</li>
</ul>
<h2 id="binary-operations"><a class="header" href="#binary-operations">Binary operations</a></h2>
<p>A <em>binary operation</em> \( \otimes \) on a set \( X \) is a function \( X \times X \to X \).
Such a binary operation is called</p>
<ul>
<li><em>associative</em>, if for all \( x, y, z \in X \), \( (x \otimes y) \otimes z = x \otimes (y \otimes z) \);</li>
<li><em>commutative</em>, if for all \( x, y \in X \), \( x \otimes y = y \otimes x \).</li>
</ul>
<h2 id="semirings"><a class="header" href="#semirings">Semirings</a></h2>
<p>A <em>semiring</em> is a set \( R \) with elements \( 0, 1 \in R \) equipped with binary operations denoted \( + \) and \( \cdot \) such that</p>
<ul>
<li>\( + \) is associative and commutative;</li>
<li>\( \cdot \) is associative and commutative;</li>
<li><em>additive identity</em>: for all \( x \in R \), \( x + 0 = x \);</li>
<li><em>multiplicative identity</em>: for all \( x \in R \), \( x \cdot 0 = 0 \) and \( x \cdot 1 = x \);</li>
<li><em>distributivity</em>: for all \( x, y, z \in R \), \( (x + y) \cdot z = x \cdot z + y \cdot z \).</li>
</ul>
<p>We write \( x y \) for \( x \cdot y \).
We also assume that semirings satisfy the following two laws.</p>
<ul>
<li><em>positivity</em>: for \( x, y \in R \), \( x + y = 0 \) implies \( x = 0 \) and \( y = 0 \).</li>
<li><em>integrality</em>: for \( x, y \in R \), \( xy = 0 \) implies either \( x = 0 \) or \( y = 0 \).</li>
</ul>
<p>We define the semiring \( R_\omega = \{ 0, 1, \omega \} \) with operations given by</p>
<ul>
<li>\( 1 + 1 = \omega \);</li>
<li>\( 1 + \omega = \omega \);</li>
<li>\( \omega + \omega = \omega \);</li>
<li>\( \omega \cdot \omega = \omega \).</li>
</ul>
<p>One can check that this structure is indeed a semiring, and satisfies positivity and integrality.</p>
<h2 id="grammars"><a class="header" href="#grammars">Grammars</a></h2>
<p>Precontexts and preterms are defined as syntax adhering to a particular grammar.
See <em>Syntax and Semantics of Quantitative Type Theory</em> (Atkey, 2018) for more information.
Before defining these grammars, we make a few initial definitions.</p>
<h3 id="usages"><a class="header" href="#usages">Usages</a></h3>
<p>An <em>extended usage</em>, to be interpreted as an element of the semiring \( R_\omega \), is of the form
\[ \pi ::= 0 \mid 1 \mid \omega \]
A <em>(binary) usage</em>, to be interpreted as either the element \( 0 \) or \( 1 \) in \( R_\omega \), is of the form
\[ \sigma ::= 0 \mid 1 \]
In our theory, terms all have an annotated binary usage.
Variables in contexts, however, may be annotated with \( 0, 1 \) or \( \omega \) usage.
The usage \( \omega \) records the fact that a resource was used multiple times; a context in which this occurs cannot typically be used in a derivation for a closed term.
There is an exception, however, in the form of <em>copyable types</em>.
The copying rule, seen later, roughly means that if we can derive a judgment under the assumption \( x \overset\omega : \alpha \), and \( \alpha \) is a copyable type, then we can derive the same consequent under the weaker assumption \( x \overset 1 : \alpha \).</p>
<h3 id="names"><a class="header" href="#names">Names</a></h3>
<p>A <em>name</em>, denoted \( x, y, z \), is a nonempty sequence of Unicode code points in the following Unicode character categories:</p>
<ul>
<li><code>L*</code> Letters</li>
<li><code>N*</code> Numbers</li>
<li><code>S*</code> Symbols</li>
</ul>
<p>A <em>qualified name</em>, denoted \( Q \), is of the form
\[ Q ::= x \mid Q :: x \]</p>
<h3 id="universes"><a class="header" href="#universes">Universes</a></h3>
<p>A <em>universe</em>, interpreted as an element of the set of natural numbers \( \mathbb N \), is of the form
\[ u, v, w ::= \{0, 1, 2, \dots \} \]
We define the operations of <em>maximum</em> and <em>impredicative maximum</em> by
\[ \mathsf{max}(u,v) =
\begin{cases}
u &amp; \text{if } u &gt; v \\
v &amp; \text{otherwise}
\end{cases};\quad
\mathsf{imax}(u,v) =
\begin{cases}
0 &amp; \text{if } v = 0 \\
\mathsf{max}(u,v) &amp; \text{otherwise}
\end{cases}
\]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preterms"><a class="header" href="#preterms">Preterms</a></h1>
<p>A <em>preterm</em>, denoted \( a, b, c, \alpha, \beta, \gamma \), is given by one of the following syntactic introduction rules.</p>
<h2 id="functional-rules"><a class="header" href="#functional-rules">Functional rules</a></h2>
<p>The basic introduction rules of functional programming are:</p>
<ul>
<li>a <em>local variable</em> \( x \);</li>
<li>an <em>application</em> \( a\ b \);</li>
<li>an <em>abstraction</em> (or \( \lambda \)-abstraction) \( \lambda (x \overset\sigma : \alpha).\, a \);</li>
<li>a <em>function type</em> (or \( \Pi \)-type) \( (x \overset\sigma : \alpha) \to \beta \);</li>
<li>a <em>let expression</em> \( \mathsf{let}\ x = a;\; b \);</li>
<li>a <em>sort</em> \( \mathsf{Sort}\ u \).</li>
</ul>
<blockquote>
<p>Note that the arguments in \( \lambda \)-abstractions and \( \Pi \)-types are annotated with a binary usage, stating whether the argument has runtime presence or not.
Importantly, there is no way for a function to consume \( \omega \) copies of an argument.</p>
</blockquote>
<p>We write \( \mathsf{Prop} = \mathsf{Sort}\ 0 \) and \( \mathsf{Type}\ u = \mathsf{Sort}\ (u + 1) \).</p>
<h2 id="environmental-rules"><a class="header" href="#environmental-rules">Environmental rules</a></h2>
<p>The introduction rules relating to declarations in the environment, such as algebraic types, are:</p>
<ul>
<li>an <em>instantiate expression</em> (or <em>inst expression</em>) \( \mathsf{inst}\ Q \);</li>
<li>an <em>intro expression</em> \( \mathsf{intro}\ Q\ a_1\ \dots\ a_r\ \mathsf{variant}\ x\ \mathsf{with}\ z_1 \mapsto c_1, \dots, z_n \mapsto c_n \);</li>
<li>a <em>match expression</em> \( \mathsf{match}\ a\ \mathsf{return}\ \alpha\ \mathsf{with}\ y_1 \mapsto b_1, \dots, y_n \mapsto b_n \);</li>
<li>a <em>fix expression</em> \( \mathsf{fix}\ (x \overset\sigma : \alpha)\ \mathsf{return}\ \beta\ \mathsf{with}\ y.\, a \).</li>
</ul>
<p>In a match expression, since the type we return could depend on the value of the major premise \( a \), we explicitly specify the type \( \alpha \) to return.</p>
<h2 id="borrowing-rules"><a class="header" href="#borrowing-rules">Borrowing rules</a></h2>
<p>The introduction rules relating to borrowing are:</p>
<ul>
<li>a <em>reference type</em> or <em>borrowed type</em> \( \mathsf{ref}\ \alpha \);</li>
<li>a <em>dereference expression</em> \( *a \);</li>
<li>a <em>loan expression</em> \( \mathsf{loan}\ x\ \mathsf{as}\ y\ \mathsf{with}\ z;\; b \);</li>
<li>a <em>take expression</em> \( \mathsf{take}\ x\ \mathsf{with}\ y_1 \mapsto a_1, \dots, y_n \mapsto a_n;\; b \);</li>
<li>an <em>in expression</em> \( a\ \mathsf{in}\ b \).</li>
</ul>
<p>In a loan expression, \( x \) is a local variable to be loaned, \( y \) is the name to assign to the borrow, and \( z \) is a local variable which will store a proof of the proposition \( *y = x \).
In the surface-level Quill syntax, a new name is not bound when loaning a variable, but it can be addressed using the syntax \( \&amp;x \).</p>
<p>In a take expression, \( x \) is the name of a local variable that was loaned earlier; this expression should be in some subexpression of the right hand side of a \( \mathsf{loan} \) expression.
Each \( y_i \) is intended to be the name of a local variable in the current context, but not in the context at the time of loaning, and the \( a_i \) is a proof that nothing depending on the memory containing \( x \) occurs in the value assigned to \( y_i \).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="precontexts"><a class="header" href="#precontexts">Precontexts</a></h1>
<p>A <em>precontext</em> is of the form
\[ \Gamma ::= \diamond \mid \Gamma, x \overset\pi : \alpha \]
We suppress the syntax &quot;\( \diamond, \)&quot; at the beginning of the expression for a precontext.
We identify precontexts that are equal up to reordering, so for example, \( x \overset{\pi_1} : \alpha, y \overset{\pi_2} : \beta \) is considered equal to \( y \overset{\pi_2} : \beta, x \overset{\pi_1} : \alpha \).
Formally, a precontext is given by the multiset of its entries.</p>
<p>We can define <em>scaling</em> of precontexts by
\[ \pi(\diamond) = \diamond;\quad \pi(\Gamma, x \overset{\pi'} : \alpha) = \pi(\Gamma), x \overset{\pi\pi'} : \alpha \]
If \( 0\Gamma_1 = 0\Gamma_2 \), then \( \Gamma_1 \) and \( \Gamma_2 \) contain the same variables with the same types, but possibly with different usage annotations.
In this case, we define <em>addition</em> of precontexts by
\[ \diamond + \diamond = \diamond;\quad (\Gamma_1, x \overset{\pi_1} : \alpha) + (\Gamma_2, x \overset{\pi_2} : \alpha) = (\Gamma_1 + \Gamma_2), x \overset{\pi_1 + \pi_2} : \alpha \]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-environments"><a class="header" href="#pre-environments">Pre-environments</a></h1>
<h2 id="pre-datatypes"><a class="header" href="#pre-datatypes">Pre-datatypes</a></h2>
<p>Feather's algebraic types are defined as follows.</p>
<p>A <em>field</em> is of the form
\[ F ::= z \overset\sigma : \gamma \]
A <em>variant</em> is of the form
\[ V ::= \varepsilon \mid F,V \]
A <em>pre-datatype</em> is
\[ T ::= \mathsf{data}\ u\ (x_1 : \alpha_1), \dots, (x_r : \alpha_r) \Rightarrow y_1 \mapsto V_1; \dots; y_n \mapsto V_n \]</p>
<p>Fields represent the objects contained within an algebraic data type.
Each field is tagged with a (binary) usage \( \sigma \), describing whether the field is to be stored at runtime.</p>
<p>The variants of a datatype are interpreted as a partition of the data type into disjoint sets.
Each variant in a datatype is tagged with its name.</p>
<p>A datatype has a universe level \( u \) in which the type lives, then a list of parameters \( \alpha_1, \dots, \alpha_r \), and finally a list of possible variants.
No usage information is attached to the parameters, as no resources are required for type creation.
In this way, an algebraic datatype is a &quot;sum of product types&quot;.</p>
<h2 id="pre-propositions"><a class="header" href="#pre-propositions">Pre-propositions</a></h2>
<p>Feather's type theory features an impredicative, proof-irrelevant universe of propositions.
We separate propositions and datatypes in order to simplify runtime code; propositions can be entirely erased, so the runtime does not need to know about the additional flexibility offered by proposition types.</p>
<p>A <em>propositional field</em> is of the form
\[ F^P ::= z : \gamma \]
A <em>propositional variant</em> is of the form
\[ V^P ::= \varepsilon \mid F^P,V^P \]
A <em>pre-proposition</em> is
\[ \begin{aligned}
P ::=\mathsf{prop}\ &amp;(x_1 : \alpha_1), \dots, (x_r : \alpha_r) \mid \beta_1, \dots, \beta_s \Rightarrow \\
&amp; y_1 \mapsto V^P_1 : b_{11}, \dots, b_{1s}; \dots; y_n \mapsto V^P_n : b_{n1}, \dots, b_{ns}
\end{aligned} \]</p>
<p>Pre-propositions are like pre-datatypes, but have more expressive flexibility.
They always have multiplicity 0.
The \( \alpha_i \) are called the <em>global parameters</em>, and the \( \beta_j \) are called the <em>index parameters</em>.
Each variant \( v \) specifies the index parameters \( b_{v1} : \beta_1, \dots, b_{vs} : \beta_s \) associated to it.</p>
<h2 id="pre-definitions"><a class="header" href="#pre-definitions">Pre-definitions</a></h2>
<p>A <em>pre-definition</em> is of the form
\[ D ::= \mathsf{def}\ a \overset\sigma : \alpha \]</p>
<h2 id="pre-environments-1"><a class="header" href="#pre-environments-1">Pre-environments</a></h2>
<p>Pre-environments store named datatypes, propositions, and definitions.
Formally, a <em>pre-environment</em> is of the form
\[ \Pi ::= \diamond \mid \Pi, Q = T \mid \Pi, Q = P \mid \Pi, Q = D \]
As with precontexts, we suppress the &quot;\( \diamond, \)&quot; syntax, and we consider two pre-environments identical if they agree up to reordering.
There is no scaling operation defined on pre-environments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="judgments"><a class="header" href="#judgments">Judgments</a></h1>
<p>We distinguish preterms from terms, precontexts from contexts, and pre-environments from environments.
In order to do this, we make use of several judgments expressed in the form of natural deduction.</p>
<ol>
<li>The judgment \( \Pi\ \mathsf{env} \) states that the pre-environment \( \Pi \) is an <em>environment</em>.</li>
<li>The judgment \( \Pi \vdash \Gamma\ \mathsf{ctx} \) states that the precontext \( \Gamma \) is a <em>context</em> in the environment \( \Pi \).</li>
<li>The judgment \( \Pi \mid \Gamma \vdash a \overset\sigma : \alpha \) states that the preterm \( a \) is a <em>term</em> of binary usage \( \sigma \) and type \( \alpha \) in the environment \( \Pi \) and context \( \Gamma \).</li>
<li>The judgment \( \Pi \mid \Gamma \vdash a \equiv b \) states that the preterms \( a \) and \( b \) are <em>definitionally equal</em>.</li>
</ol>
<h2 id="admissible-rules"><a class="header" href="#admissible-rules">Admissible rules</a></h2>
<p>We construct our theory in such a way that the following rules are admissible.
\[ \frac{\Pi \mid \Gamma \vdash a \overset\sigma : \alpha}{\Pi \vdash \Gamma\ \mathsf{ctx}};\quad
\frac{\Pi \mid \Gamma \vdash a \equiv b}{\Pi \vdash \Gamma\ \mathsf{ctx}};\quad
\frac{\Pi \vdash \Gamma\ \mathsf{ctx}}{\Pi\ \mathsf{env}} \]
\[ \frac{\Pi \vdash \Gamma_1\ \mathsf{ctx} \quad 0\Gamma_1 = 0\Gamma_2}{\Pi \vdash \Gamma_2\ \mathsf{ctx}};\quad
\frac{\Pi \mid \Gamma \vdash a \overset\sigma : \alpha}{\Pi \mid 0\Gamma \vdash a \overset 0 : \alpha} \]</p>
<h2 id="contexts"><a class="header" href="#contexts">Contexts</a></h2>
<p>We stipulate the rules
\[ \frac{\Pi\ \mathsf{env}}{\Pi \vdash \diamond\ \mathsf{ctx}};\quad
\frac{\Pi \vdash \Gamma\ \mathsf{ctx} \quad \Pi \vdash 0\Gamma \vdash \alpha \overset 0 : \mathsf{Sort}\ u}{\Pi \vdash \Gamma, x \overset\pi : \alpha\ \mathsf{ctx}} \]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-typing-rules"><a class="header" href="#functional-typing-rules">Functional typing rules</a></h1>
<p>We present typing rules for each of the functional expression types.</p>
<h2 id="local-variables"><a class="header" href="#local-variables">Local variables</a></h2>
<p>We can obtain a local variable from a context.
\[ \frac{\Pi \vdash 0\Gamma, x \overset\sigma : \alpha \ \mathsf{ctx}}{\Pi \mid 0\Gamma, x \overset\sigma : \alpha \vdash x \overset\sigma : \alpha} \]
The use of \( 0\Gamma \) implies that the resources in the context are not used in the construction of the term \( x \).</p>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<p>\[ \frac{\Pi \mid \Gamma_1 \vdash a \overset{\sigma_1} : (x \overset{\sigma_2} : \alpha) \to \beta \quad \Pi \mid \Gamma_2 \vdash b \overset{\sigma_1 \sigma_2} : \alpha \quad 0\Gamma_1 = 0\Gamma_2}{\Pi \mid \Gamma_1 + \Gamma_2 \vdash a\ b \overset{\sigma_1} : \beta[b/x]} \]</p>
<blockquote>
<p>Note that unless \( \sigma_1 = \sigma_2 = 1 \), we used no resources to construct \( b \), due to the &quot;zero needs nothing&quot; rule.
(TODO: Describe this rule.)
The context in the conclusion of this rule can therefore be reduced from the standard QTT form of \( \Gamma_1 + \sigma_2 \Gamma_2 \) to just \( \Gamma_1 + \Gamma_2 \).
This observation simplifies our presentation of the function application rule somewhat.
In quantitative type theory more generally, the usage \( \sigma_2 \) could be any element of an arbitrary semiring \( R \), so the same modification cannot be made there.</p>
</blockquote>
<p>We describe the interpretations of each instance of this rule.</p>
<ul>
<li>\( \sigma_1 = 0, \sigma_2 = 0 \).
We consume and produce no resources.
This is a function application rule that ignores usage labels.</li>
<li>\( \sigma_1 = 0, \sigma_2 = 1 \).
The function expects that its parameter is a resource.
But since the function is erased, the computation is not executed at runtime, so the resource is not needed.
The conclusion of the judgment is therefore \( \Pi \mid \Gamma_1 + 0\Gamma_2 \vdash a\ b \overset 0 : \beta[b/x] \).</li>
<li>\( \sigma_1 = 1, \sigma_2 = 0 \).
In this case, the function is a resource, and its argument is erased.
We can evaluate the function on an erased argument.</li>
<li>\( \sigma_1 = 1, \sigma_2 = 1 \).
This is the standard function application rule from linear logic.
The function and its argument are used exactly once.</li>
</ul>
<h2 id="abstractions"><a class="header" href="#abstractions">Abstractions</a></h2>
<p>\[ \frac{\Pi \mid \Gamma, x \overset{\sigma_1\sigma_2} : \alpha \vdash b \overset{\sigma_1} : \beta}{\Pi \mid \Gamma \vdash \lambda(x \overset{\sigma_2} : \alpha).\,b \overset{\sigma_1} : (x \overset{\sigma_2} : \alpha) \to \beta} \]</p>
<h2 id="function-types"><a class="header" href="#function-types">Function types</a></h2>
<p>\[ \frac{\Pi \mid 0\Gamma \vdash \alpha \overset 0 : \mathsf{Sort}\, u \quad \Pi \mid 0\Gamma, x \overset 0 : \alpha \vdash \beta \overset 0 : \mathsf{Sort}\, v}{\Pi \mid 0\Gamma \vdash (x \overset \sigma : \alpha) \to \beta \overset 0 : \mathsf{Sort}\, \mathsf{imax}(u, v)} \]</p>
<h2 id="let-expressions"><a class="header" href="#let-expressions">Let expressions</a></h2>
<p>\[ \frac{\Pi \mid \Gamma_1 \vdash a \overset{\sigma_1\sigma_2} : \alpha \quad \Pi \mid \Gamma_2, x \overset{\sigma_1\sigma_2} : \alpha \vdash b \overset{\sigma_2} : \beta \quad 0\Gamma_1 = 0\Gamma_2}{\Pi \mid \Gamma_1 + \Gamma_2 \vdash \mathsf{let}_{\sigma_1\sigma_2}\ x = a;\, b \overset{\sigma_2} : \beta} \]</p>
<p>This rule admits three forms.</p>
<ul>
<li>\( \sigma_1 \) arbitrary, \( \sigma_2 = 0 \).
The ambient context is erased, so the let-binding is also erased.</li>
<li>\( \sigma_1 = 0, \sigma_2 = 1 \).
The ambient context exists at runtime, but we are constructing an erased value.</li>
<li>\( \sigma_1 = 1, \sigma_2 = 1 \).
The standard \( \mathsf{let} \) rule from linear logic.</li>
</ul>
<h2 id="sort-expressions"><a class="header" href="#sort-expressions">Sort expressions</a></h2>
<p>\[ \frac{\Pi \vdash 0\Gamma\ \mathsf{ctx}}{\Pi \mid 0\Gamma \vdash \mathsf{Sort}\ u \overset 0 : \mathsf{Sort}\ (u + 1)} \]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environmental-typing-rules"><a class="header" href="#environmental-typing-rules">Environmental typing rules</a></h1>
<p>For clarity, we describe the typing rule for some expressions in English rather than through mathematical symbols.</p>
<h2 id="instantiate-expressions"><a class="header" href="#instantiate-expressions">Instantiate expressions</a></h2>
<p>In the following rules, the precise syntax of the \( \mathsf{data} \) and \( \mathsf{prop} \) intro rules is shortened for brevity.</p>
<p>\[ \frac{\Pi, Q = \mathsf{data}\ u\ \dots \vdash 0\Gamma\ \mathsf{ctx}}{\Pi, Q = \mathsf{data}\ u\ \dots \mid 0\Gamma \vdash \mathsf{inst}\ Q \overset 0 : \mathsf{Type}\ u} \]</p>
<p>This rule ascribes meaning to the act of placing a datatype in the environment, by allowing it to be used as a type in an appropriate context.
In particular, the universe \( u \) defines the sort in which the datatype resides.</p>
<p>\[ \frac{\Pi, Q = \mathsf{prop}\ \dots \vdash 0\Gamma\ \mathsf{ctx}}{\Pi, Q = \mathsf{prop}\ \dots \mid 0\Gamma \vdash \mathsf{inst}\ Q \overset 0 : \mathsf{Prop}} \]</p>
<p>This rule is like the previous one, except that propositions always live in the sort \( \mathsf{Prop} \).</p>
<p>\[ \frac{\Pi, Q = \mathsf{def}\ a \overset\sigma : \alpha \vdash 0\Gamma\ \mathsf{ctx}}{\Pi, Q = \mathsf{def}\ a \overset\sigma : \alpha \mid 0\Gamma \vdash \mathsf{inst}\ Q \overset{\sigma\sigma'} : \alpha} \]</p>
<p>When instantiating a definition, we can choose to instantiate it with the usage it was defined, or erase it.</p>
<h2 id="intro-expressions"><a class="header" href="#intro-expressions">Intro expressions</a></h2>
<p>Suppose the environment \( \Pi \) contains
\[ \mathsf{data}\ u\ (x_1 : \alpha_1), \dots, (x_r : \alpha_r) \Rightarrow y_1 \mapsto V_1; \dots; y_n \mapsto V_n \]
assigned to the name \( Q \), and we wish to assign a type to the term
\[ t ::= \mathsf{intro}\ Q\ a_1\ \dots\ a_r\ \mathsf{variant}\ y\ \mathsf{with}\ z_1 \mapsto c_1, \dots, z_m \mapsto c_m \]
We assume that we wish to construct \( t \) with usage \( \sigma \).
First, we check that for each \( i = 1, \dots, r \), we have
\[ \Pi \mid 0\Gamma \vdash a_i \overset 0 : \alpha_i[a_1/x_1, \dots, a_{i-1}/x_{i-1}] \]
This ensures that the global parameters for the datatype are type correct.
We then check that \( y \) is one of the variants \( y_1, \dots, y_n \).
Suppose \( y = y_i \), and \( V_i = z_1 \overset{\sigma_1} : \gamma_1, \dots, z_m \overset{\sigma_m} : \gamma_m \).
We implicitly assume in this statement that the names of the fields in \( V_i \) agree with the arguments of the \( \mathsf{intro} \) expression.
Then for each \( j = 1, \dots, m \), we check that
\[ \Pi \mid \Gamma \vdash c_j \overset {\sigma\sigma_j} : \gamma_j[a_1/x_1, \dots, a_n/x_n, c_1/z_1, \dots, c_{j-1}/z_{j-1}] \]
If all of these constraints can be satisfied concurrently (using the sum of the relevant contexts \( \Gamma \)), we conclude
\[ t \overset\sigma : Q\ a_1\ \dots\ a_r \]
Suppose instead that \( \Pi \) assigns the proposition type
\[ \begin{aligned}
\mathsf{prop}\ &amp;(x_1 : \alpha_1), \dots, (x_r : \alpha_r) \mid \beta_1, \dots, \beta_s \Rightarrow \\
&amp; y_1 \mapsto V^P_1 : b_{11}, \dots, b_{1s}; \dots; y_n \mapsto V^P_n : b_{n1}, \dots, b_{ns}
\end{aligned} \]
to the name \( Q \).
We first check that all of the global parameters are correctly typed as above, and similarly ensure that \( y = y_i \) for some \( i \).
For each field \( j \) in the propositional variant \( V_i^P = z_1 : \gamma_1, \dots, z_m : \gamma_m \), we verify that
\[ \Pi \mid 0\Gamma \vdash c_j \overset 0 : \gamma_j[a_1/x_1, \dots, a_n/x_n, c_1/z_1, \dots, c_{j-1}/z_{j-1}] \]
Then, we conclude
\[ t \overset 0 : Q\ a_1\ \dots\ a_r\ (b_{i1}\ \dots\ b_{is})[a_1/x_1, \dots, a_r/x_r, c_1/z_1, \dots, c_m/z_m] \]</p>
<h2 id="match-expressions"><a class="header" href="#match-expressions">Match expressions</a></h2>
<!-- TODO: How do we do Fn vs FnOnce in the current type system? Do we really need to have \to and \implies be different? I think this is the cleanest way. -->
<p>Suppose we wish to typecheck
\[ t ::= \mathsf{match}\ a\ \mathsf{return}\ \alpha\ \mathsf{with}\ y_1 \mapsto b_1, \dots, y_n \mapsto b_n \]
First, suppose \( \Pi \) contains
\[ \mathsf{data}\ u\ (x_1 : \alpha_1), \dots, (x_r : \alpha_r) \Rightarrow y_1 \mapsto V_1; \dots; y_n \mapsto V_n \]
assigned to the name \( Q \), and we check \( a \overset \sigma : Q\ a_1\ \dots\ a_r \).
Implicitly, we are assuming that the names of the variants of \( Q \) match with the arguments of the \( \mathsf{match} \) expression.
We then check that, for some \( u \),
\[ \Pi \mid 0\Gamma \vdash \alpha \overset 0 : (x \overset 0 : Q\ a_1\ \dots\ a_r) \to \mathsf{Sort}\ u \]
We now verify that each \( b_i \) is well-typed.
Specifically, if \( V_i = z_1 \overset{\sigma_1} : \gamma_1, \dots, z_m \overset{\sigma_m} : \gamma_m \), we check that
\[ \begin{aligned}
\Pi \mid \Gamma \vdash\, &amp;b_i \overset\sigma : (z_1 \overset{\sigma_1} : \gamma_1) \to \dots \to (z_m \overset{\sigma_m} : \gamma_m) \to \\
&amp;\alpha\ (\mathsf{intro}\ Q\ a_1\ \dots\ a_r\ \mathsf{variant}\ y_i\ \mathsf{with}\ z_1 \mapsto z_1, \dots, z_m \mapsto z_m)
\end{aligned} \]
If all of these checks pass, we conclude
\[ \Pi \mid \Gamma \vdash t \overset \sigma : \alpha\ a \]
Now, suppose \( \Pi \) binds the name \( Q \) to the proposition
\[ \begin{aligned}
\mathsf{prop}\ &amp;(x_1 : \alpha_1), \dots, (x_r : \alpha_r) \mid \beta_1, \dots, \beta_s \Rightarrow \\
&amp; y_1 \mapsto V^P_1 : b_{11}, \dots, b_{1s}; \dots; y_n \mapsto V^P_n : b_{n1}, \dots, b_{ns}
\end{aligned} \]
In this case, we require \( \sigma = 0 \).
We check \( a \overset 0 : Q\ a_1\ \dots\ a_r\ a_1'\ \dots\ a_s' \).
Then, we verify that
\[ \Pi \mid 0\Gamma \vdash \alpha \overset 0 : (x_1' \overset 0 : \beta_1) \to \dots \to (x_s' \overset 0 : \beta_s) \to (x \overset 0 : Q\ a_1\ \dots\ a_r\ x_1'\ \dots\ x_s') \to \mathsf{Sort}\ u \]
At this stage, we ensure that \( u \) is a valid universe to eliminate into for this particular proposition.
We perform the following sequence of checks.</p>
<ul>
<li>
<p>If \( Q \) has no variants, \( u \) may be any universe.</p>
</li>
<li>
<p>If \( Q \) has at least two variants, \( u \) must be \( 0 \); we can only eliminate into \( \mathsf{Prop} \).</p>
</li>
<li>
<p>Suppose \( Q \) has one variant \( V^P \). If every field satisfies either</p>
<ol>
<li>its type lies in \( \mathsf{Prop} \); or</li>
<li>it occurs in one of the index parameters \( b_{11}, \dots, b_{1s} \),</li>
</ol>
<p>then \( u \) may be any universe.
If any field fails to satisfy both requirements, \( u \) must be \( 0 \).</p>
</li>
</ul>
<p>We now check that each \( b_i \) is well-typed.
Suppose we are considering the variant \( V^P_i = (z_1 : \gamma_1, \dots, z_m : \gamma_m) : b_{i1}, \dots, b_{is} \).
Then, we check
\[ \begin{aligned}
\Pi \mid \Gamma \vdash\, &amp;b_i \overset 0 : (z_1 \overset 0 : \gamma_1) \to \dots \to (z_m \overset 0 : \gamma_m) \to \\
&amp;\alpha\ b_{i1}\ \dots\ b_{is}\ (\mathsf{intro}\ Q\ a_1\ \dots\ a_r\ \mathsf{variant}\ y_i\ \mathsf{with}\ z_1 \mapsto z_1, \dots, z_m \mapsto z_m)
\end{aligned} \]
We finally conclude
\[ \Pi \mid \Gamma \vdash t \overset 0 : \alpha\ a_1'\ \dots\ a_s'\ a \]</p>
<blockquote>
<p>TODO: Can we get away with \( \sigma \) usage in some cases, such as to perform casts between propositionally equal types?</p>
</blockquote>
<h2 id="fix-expressions"><a class="header" href="#fix-expressions">Fix expressions</a></h2>
<p>Finally, suppose we wish to typecheck
\[ \mathsf{fix}\ (x \overset\sigma : \alpha)\ \mathsf{return}\ \beta\ \mathsf{with}\ y.\, a \]
First, we ensure that \( \alpha \) is an algebraic datatype or a propositional type.
If \( \alpha \) is a propositional type, we assume \( \sigma = 0 \).
We now check that
\[ \Pi \mid 0\Gamma \vdash \beta \overset 0 : (x \overset 0 : \alpha) \to \mathsf{Sort}\ u \]
and
\[ \Pi \mid \Gamma, x \overset\sigma : \alpha, y \overset\sigma : (x \overset\sigma : \alpha) \Rightarrow \beta\ x \vdash a \overset\sigma : \beta\ x \]
Now, we check that each use of \( y \) in \( a \) occurs as a function in an application expression, where the argument is one of the bound variables from a match expression on \( x \), possibly with some arguments applied to it.
This restriction ensures that the fixpoint function we describe will terminate on all inputs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing-typing-rules"><a class="header" href="#borrowing-typing-rules">Borrowing typing rules</a></h1>
<p>We assume \( \Pi \) contains the definition \( ¬ : \mathsf{Prop} \to \mathsf{Prop} \).</p>
<p>For each \( A : \mathsf{Sort}\ u \), we assume \( \Pi \) contains the type \( =_A \).</p>
<ul>
<li>The global parameters are \( A : \mathsf{Sort}\ u \) and \( a : A \).</li>
<li>There is one index parameter, \( b : A \).</li>
<li>There is one variant, named \( \mathsf{refl} \), with no fields, and index parameter assignment \( a \).</li>
</ul>
<h2 id="reference-types"><a class="header" href="#reference-types">Reference types</a></h2>
<p>\[ \frac{\Pi \mid 0\Gamma \vdash \alpha \overset 0 : \mathsf{Sort}\ u}{\Pi \mid 0\Gamma \vdash \mathsf{ref}\ \alpha \overset 0 : \mathsf{Sort}\ u} \]</p>
<h2 id="dereference-expressions"><a class="header" href="#dereference-expressions">Dereference expressions</a></h2>
<p>\[ \frac{\Pi \mid 0\Gamma \vdash a \overset 0 : \mathsf{ref}\ \alpha}{\Pi \mid 0\Gamma \vdash *a \overset 0 : \alpha} \]</p>
<h2 id="loan-expressions"><a class="header" href="#loan-expressions">Loan expressions</a></h2>
<p>\[ \frac{\Pi \mid \Gamma, x \overset 0 : \alpha, y \overset 1 : \mathsf{ref}\ \alpha, z \overset 0 : x =_{\mathsf{ref}\ \alpha} *y \vdash b \overset 1 : \beta}{\Pi \mid \Gamma, x \overset 1 : \alpha \vdash \mathsf{loan}\ x\ \mathsf{as}\ y\ \mathsf{with}\ z;\; b \overset 1 : \beta} \]</p>
<p>We add the additional constraint that, in every code path in \( b \), there is a unique \( \mathsf{take}\ x \) expression, not enclosed in any abstraction.</p>
<h2 id="take-expressions"><a class="header" href="#take-expressions">Take expressions</a></h2>
<p>\[ \frac{\Pi \mid \Gamma, x \overset 1 : \alpha \vdash b \overset 1 : \beta \quad \Pi \mid 0\Gamma, x \overset 0 : \alpha \vdash a_1 \overset 0 : ¬(x\ \mathsf{in}\ y_1) \ \dots \ \Pi \mid 0\Gamma, x \overset 0 : \alpha \vdash a_n \overset 0 : ¬(x\ \mathsf{in}\ y_n)}{\Pi \mid \Gamma, x \overset 0 : \alpha \vdash \mathsf{take}\ x\ \mathsf{with}\ y_1 \mapsto a_1, \dots, y_n \mapsto a_n;\; b \overset 1 : \beta} \]</p>
<p>We add the constraint that this \( \mathsf{take} \) expression occurs in the body of a \( \mathsf{loan}\ x \) expression.
We also stipulate that the names \( y_1, \dots, y_n \) correspond to the variables bound between the loan and take expressions.</p>
<h2 id="in-expressions"><a class="header" href="#in-expressions">In expressions</a></h2>
<p>\[ \frac{\Pi \mid 0\Gamma \vdash a \overset 0 : \mathsf{ref}\ \alpha \quad \Pi \mid 0\Gamma \vdash b \overset 0 : \beta}{\Pi \mid 0\Gamma \vdash a\ \mathsf{in}\ b \overset 0 : \mathsf{Prop}} \]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="definitional-equality"><a class="header" href="#definitional-equality">Definitional equality</a></h1>
<p>The rules used to derive definitional equality require no resources.</p>
<h2 id="equality-as-an-equivalence-relation"><a class="header" href="#equality-as-an-equivalence-relation">Equality as an equivalence relation</a></h2>
<p>The <em>reflexivity</em> rule is
\[ \frac{\Pi \mid 0\Gamma \vdash a \overset 0 : \alpha}{\Pi \mid 0\Gamma \vdash a \equiv a} \]
The <em>symmetry</em> rule is
\[ \frac{\Pi \mid 0\Gamma \vdash a \equiv b}{\Pi \mid 0\Gamma \vdash b \equiv a} \]
The <em>transitivity</em> rule is
\[ \frac{\Pi \mid 0\Gamma \vdash a \equiv b \quad \Pi \mid 0\Gamma \vdash b \equiv c}{\Pi \mid 0\Gamma \vdash a \equiv c} \]</p>
<h2 id="type-conversion"><a class="header" href="#type-conversion">Type conversion</a></h2>
<p>Terms can be reinterpreted as a definitionally equal type.
The <em>type conversion</em> rule is
\[ \frac{\Pi \mid \Gamma \vdash a \overset\sigma : \alpha \quad \Pi \mid 0\Gamma \vdash \alpha \equiv \beta}{\Pi \mid \Gamma \vdash a \overset\sigma : \beta} \]</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
